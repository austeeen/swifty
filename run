#!/usr/bin/env bash

quit() {
    exit $1
}

errcheck() {
    if [[ $1 -ne 0 ]]; then
        quit 1
    fi
}

usage () {
    echo "run [OPTIONS]+ [APP OPTIONS]"
    echo "  build and/or run the app"
    echo "  at least one OPTION is required."
    echo "  OPTIONS are listed as single chars with no whitespace"
    echo "     ex: 'rb' uses r and b to build then run the app."
    echo "[OPTIONS]"
    echo "  b - build regularly"
    echo "  c - clear all build files first, then build the app"
    echo "  r - run app in the build dir"
    echo "  g - same as 'r' but using gdb"
    echo "  v - same as 'r' but using valgrind"
    echo "  p - same as 'v' but more options for detailed profiling with valgrind"
    echo "  h - display this help blurb"
}

app="swifty"
base_cmd="build/$app.app"

run_cmd=""
do_clean=0
do_build=0
do_run=0

if [[ $# -lt 1 ]]; then
    echo "ERROR: not enough arguments! use h to display help and info."
    quit 1
fi

args=($(echo $1 | grep -o .))
shift

build () {
    echo "building '$app'"
    mkdir -p build && cd build
    errcheck $?
    if [[ $do_clean == 1 ]]; then
        rm -rf ./*
        errcheck $?
    fi
    cmake -DAPP_NAME=$app ..
    errcheck $?
    cmake --build .
    errcheck $?
    cd ..
}

for c in "${args[@]}"; do
    case $c in
        b)
            do_build=1;;
        c)
            do_build=1
            do_clean=1;;
        g)
            run_cmd="gdb $base_cmd"
            do_run=1;;
        r)
            run_cmd="$base_cmd"
            do_run=1;;
        v)
            run_cmd="valgrind --track-origins=yes --leak-check=yes --log-file='valgrind.log' $base_cmd"
            do_run=1;;
        p)
            run_cmd="valgrind --tool=callgrind $base_cmd"
            do_run=1;;
        h)
            usage;;
        *)
            echo "bad arg: $c";;
  esac
done

if [[ $do_build -eq 1 ]]; then
    build
fi

if [[ $do_run -eq 1 ]]; then
    eval "$run_cmd $@"
fi

quit 0
